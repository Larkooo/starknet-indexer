// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gql

import (
	"bytes"
	"context"
	"errors"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/tarrencev/starknet-indexer/ent"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Block struct {
		BlockHash       func(childComplexity int) int
		BlockNumber     func(childComplexity int) int
		ID              func(childComplexity int) int
		ParentBlockHash func(childComplexity int) int
		StateRoot       func(childComplexity int) int
		Status          func(childComplexity int) int
		Timestamp       func(childComplexity int) int
	}

	BlockConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	BlockEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		Blocks func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.BlockOrder, where *BlockWhereInput) int
		Node   func(childComplexity int, id string) int
		Nodes  func(childComplexity int, ids []string) int
	}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Block.blockHash":
		if e.complexity.Block.BlockHash == nil {
			break
		}

		return e.complexity.Block.BlockHash(childComplexity), true

	case "Block.blockNumber":
		if e.complexity.Block.BlockNumber == nil {
			break
		}

		return e.complexity.Block.BlockNumber(childComplexity), true

	case "Block.id":
		if e.complexity.Block.ID == nil {
			break
		}

		return e.complexity.Block.ID(childComplexity), true

	case "Block.parentBlockHash":
		if e.complexity.Block.ParentBlockHash == nil {
			break
		}

		return e.complexity.Block.ParentBlockHash(childComplexity), true

	case "Block.stateRoot":
		if e.complexity.Block.StateRoot == nil {
			break
		}

		return e.complexity.Block.StateRoot(childComplexity), true

	case "Block.status":
		if e.complexity.Block.Status == nil {
			break
		}

		return e.complexity.Block.Status(childComplexity), true

	case "Block.timestamp":
		if e.complexity.Block.Timestamp == nil {
			break
		}

		return e.complexity.Block.Timestamp(childComplexity), true

	case "BlockConnection.edges":
		if e.complexity.BlockConnection.Edges == nil {
			break
		}

		return e.complexity.BlockConnection.Edges(childComplexity), true

	case "BlockConnection.pageInfo":
		if e.complexity.BlockConnection.PageInfo == nil {
			break
		}

		return e.complexity.BlockConnection.PageInfo(childComplexity), true

	case "BlockConnection.totalCount":
		if e.complexity.BlockConnection.TotalCount == nil {
			break
		}

		return e.complexity.BlockConnection.TotalCount(childComplexity), true

	case "BlockEdge.cursor":
		if e.complexity.BlockEdge.Cursor == nil {
			break
		}

		return e.complexity.BlockEdge.Cursor(childComplexity), true

	case "BlockEdge.node":
		if e.complexity.BlockEdge.Node == nil {
			break
		}

		return e.complexity.BlockEdge.Node(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.blocks":
		if e.complexity.Query.Blocks == nil {
			break
		}

		args, err := ec.field_Query_blocks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Blocks(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.BlockOrder), args["where"].(*BlockWhereInput)), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(string)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]string)), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "entgql.graphql", Input: `directive @goField(forceResolver: Boolean, name: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!]) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
type Block implements Node {
  id: ID!
  blockHash: String!
  parentBlockHash: String!
  blockNumber: Long!
  stateRoot: String!
  status: String!
  timestamp: Time!
}
"""A connection to a list of items."""
type BlockConnection {
  """A list of edges."""
  edges: [BlockEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  totalCount: Int!
}
"""An edge in a connection."""
type BlockEdge {
  """The item at the end of the edge."""
  node: Block
  """A cursor for use in pagination."""
  cursor: Cursor!
}
input BlockOrder {
  direction: OrderDirection! = ASC
  field: BlockOrderField!
}
enum BlockOrderField {
  TIMESTAMP
}
"""
BlockWhereInput is used for filtering Block objects.
Input was generated by ent.
"""
input BlockWhereInput {
  not: BlockWhereInput
  and: [BlockWhereInput!]
  or: [BlockWhereInput!]
  """block_hash field predicates"""
  blockHash: String
  blockHashNEQ: String
  blockHashIn: [String!]
  blockHashNotIn: [String!]
  blockHashGT: String
  blockHashGTE: String
  blockHashLT: String
  blockHashLTE: String
  blockHashContains: String
  blockHashHasPrefix: String
  blockHashHasSuffix: String
  blockHashEqualFold: String
  blockHashContainsFold: String
  """parent_block_hash field predicates"""
  parentBlockHash: String
  parentBlockHashNEQ: String
  parentBlockHashIn: [String!]
  parentBlockHashNotIn: [String!]
  parentBlockHashGT: String
  parentBlockHashGTE: String
  parentBlockHashLT: String
  parentBlockHashLTE: String
  parentBlockHashContains: String
  parentBlockHashHasPrefix: String
  parentBlockHashHasSuffix: String
  parentBlockHashEqualFold: String
  parentBlockHashContainsFold: String
  """block_number field predicates"""
  blockNumber: Long
  blockNumberNEQ: Long
  blockNumberIn: [Long!]
  blockNumberNotIn: [Long!]
  blockNumberGT: Long
  blockNumberGTE: Long
  blockNumberLT: Long
  blockNumberLTE: Long
  """state_root field predicates"""
  stateRoot: String
  stateRootNEQ: String
  stateRootIn: [String!]
  stateRootNotIn: [String!]
  stateRootGT: String
  stateRootGTE: String
  stateRootLT: String
  stateRootLTE: String
  stateRootContains: String
  stateRootHasPrefix: String
  stateRootHasSuffix: String
  stateRootEqualFold: String
  stateRootContainsFold: String
  """status field predicates"""
  status: String
  statusNEQ: String
  statusIn: [String!]
  statusNotIn: [String!]
  statusGT: String
  statusGTE: String
  statusLT: String
  statusLTE: String
  statusContains: String
  statusHasPrefix: String
  statusHasSuffix: String
  statusEqualFold: String
  statusContainsFold: String
  """timestamp field predicates"""
  timestamp: Time
  timestampNEQ: Time
  timestampIn: [Time!]
  timestampNotIn: [Time!]
  timestampGT: Time
  timestampGTE: Time
  timestampLT: Time
  timestampLTE: Time
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
}
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node {
  """The id of the object."""
  id: ID!
}
enum OrderDirection {
  ASC
  DESC
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!
  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!
  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor
  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}
`, BuiltIn: false},
	{Name: "schema.graphql", Input: `scalar Time
scalar Long

type Query {
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]!
  blocks(
    after: Cursor
    first: Int
    before: Cursor
    last: Int
    orderBy: BlockOrder
    where: BlockWhereInput
  ): BlockConnection
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
