// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gql

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/tarrencev/starknet-indexer/ent"
	"github.com/tarrencev/starknet-indexer/ent/block"
	"github.com/tarrencev/starknet-indexer/ent/transaction"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Block_id(ctx context.Context, field graphql.CollectedField, obj *ent.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_blockHash(ctx context.Context, field graphql.CollectedField, obj *ent.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_blockHash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_blockHash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_parentBlockHash(ctx context.Context, field graphql.CollectedField, obj *ent.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_parentBlockHash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentBlockHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_parentBlockHash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_blockNumber(ctx context.Context, field graphql.CollectedField, obj *ent.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_blockNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNLong2uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_blockNumber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Long does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_stateRoot(ctx context.Context, field graphql.CollectedField, obj *ent.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_stateRoot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StateRoot, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_stateRoot(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_status(ctx context.Context, field graphql.CollectedField, obj *ent.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(block.Status)
	fc.Result = res
	return ec.marshalNBlockStatus2githubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚋblockᚐStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BlockStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_timestamp(ctx context.Context, field graphql.CollectedField, obj *ent.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlockConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.BlockConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlockConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.BlockEdge)
	fc.Result = res
	return ec.marshalOBlockEdge2ᚕᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐBlockEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlockConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlockConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_BlockEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_BlockEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BlockEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlockConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.BlockConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlockConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlockConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlockConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlockConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.BlockConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlockConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlockConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlockConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlockEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.BlockEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlockEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Block)
	fc.Result = res
	return ec.marshalOBlock2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐBlock(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlockEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlockEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Block_id(ctx, field)
			case "blockHash":
				return ec.fieldContext_Block_blockHash(ctx, field)
			case "parentBlockHash":
				return ec.fieldContext_Block_parentBlockHash(ctx, field)
			case "blockNumber":
				return ec.fieldContext_Block_blockNumber(ctx, field)
			case "stateRoot":
				return ec.fieldContext_Block_stateRoot(ctx, field)
			case "status":
				return ec.fieldContext_Block_status(ctx, field)
			case "timestamp":
				return ec.fieldContext_Block_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Block", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlockEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.BlockEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlockEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlockEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlockEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *ent.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *ent.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPreviousPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *ent.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_startCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Cursor)
	fc.Result = res
	return ec.marshalOCursor2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_startCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *ent.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_endCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Cursor)
	fc.Result = res
	return ec.marshalOCursor2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_endCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_id(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_contractAddress(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_contractAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContractAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_contractAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_entryPointSelector(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_entryPointSelector(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EntryPointSelector, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_entryPointSelector(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_entryPointType(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_entryPointType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EntryPointType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_entryPointType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_transactionHash(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_transactionHash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TransactionHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_transactionHash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_type(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(transaction.Type)
	fc.Result = res
	return ec.marshalNType2githubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚋtransactionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Type does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_nonce(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_nonce(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nonce, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_nonce(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.TransactionEdge)
	fc.Result = res
	return ec.marshalOTransactionEdge2ᚕᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐTransactionEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_TransactionEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_TransactionEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Transaction)
	fc.Result = res
	return ec.marshalOTransaction2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐTransaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Transaction_id(ctx, field)
			case "contractAddress":
				return ec.fieldContext_Transaction_contractAddress(ctx, field)
			case "entryPointSelector":
				return ec.fieldContext_Transaction_entryPointSelector(ctx, field)
			case "entryPointType":
				return ec.fieldContext_Transaction_entryPointType(ctx, field)
			case "transactionHash":
				return ec.fieldContext_Transaction_transactionHash(ctx, field)
			case "type":
				return ec.fieldContext_Transaction_type(ctx, field)
			case "nonce":
				return ec.fieldContext_Transaction_nonce(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Transaction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputBlockOrder(ctx context.Context, obj interface{}) (ent.BlockOrder, error) {
	var it ent.BlockOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	for k, v := range asMap {
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2githubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNBlockOrderField2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐBlockOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBlockWhereInput(ctx context.Context, obj interface{}) (BlockWhereInput, error) {
	var it BlockWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOBlockWhereInput2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋgqlᚐBlockWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOBlockWhereInput2ᚕᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋgqlᚐBlockWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOBlockWhereInput2ᚕᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋgqlᚐBlockWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "blockHash":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockHash"))
			it.BlockHash, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "blockHashNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockHashNEQ"))
			it.BlockHashNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "blockHashIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockHashIn"))
			it.BlockHashIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "blockHashNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockHashNotIn"))
			it.BlockHashNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "blockHashGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockHashGT"))
			it.BlockHashGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "blockHashGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockHashGTE"))
			it.BlockHashGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "blockHashLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockHashLT"))
			it.BlockHashLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "blockHashLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockHashLTE"))
			it.BlockHashLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "blockHashContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockHashContains"))
			it.BlockHashContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "blockHashHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockHashHasPrefix"))
			it.BlockHashHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "blockHashHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockHashHasSuffix"))
			it.BlockHashHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "blockHashEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockHashEqualFold"))
			it.BlockHashEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "blockHashContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockHashContainsFold"))
			it.BlockHashContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "parentBlockHash":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentBlockHash"))
			it.ParentBlockHash, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "parentBlockHashNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentBlockHashNEQ"))
			it.ParentBlockHashNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "parentBlockHashIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentBlockHashIn"))
			it.ParentBlockHashIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "parentBlockHashNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentBlockHashNotIn"))
			it.ParentBlockHashNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "parentBlockHashGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentBlockHashGT"))
			it.ParentBlockHashGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "parentBlockHashGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentBlockHashGTE"))
			it.ParentBlockHashGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "parentBlockHashLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentBlockHashLT"))
			it.ParentBlockHashLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "parentBlockHashLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentBlockHashLTE"))
			it.ParentBlockHashLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "parentBlockHashContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentBlockHashContains"))
			it.ParentBlockHashContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "parentBlockHashHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentBlockHashHasPrefix"))
			it.ParentBlockHashHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "parentBlockHashHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentBlockHashHasSuffix"))
			it.ParentBlockHashHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "parentBlockHashEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentBlockHashEqualFold"))
			it.ParentBlockHashEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "parentBlockHashContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentBlockHashContainsFold"))
			it.ParentBlockHashContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "blockNumber":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockNumber"))
			it.BlockNumber, err = ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
		case "blockNumberNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockNumberNEQ"))
			it.BlockNumberNeq, err = ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
		case "blockNumberIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockNumberIn"))
			it.BlockNumberIn, err = ec.unmarshalOLong2ᚕuint64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "blockNumberNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockNumberNotIn"))
			it.BlockNumberNotIn, err = ec.unmarshalOLong2ᚕuint64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "blockNumberGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockNumberGT"))
			it.BlockNumberGt, err = ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
		case "blockNumberGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockNumberGTE"))
			it.BlockNumberGte, err = ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
		case "blockNumberLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockNumberLT"))
			it.BlockNumberLt, err = ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
		case "blockNumberLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockNumberLTE"))
			it.BlockNumberLte, err = ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
		case "stateRoot":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stateRoot"))
			it.StateRoot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "stateRootNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stateRootNEQ"))
			it.StateRootNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "stateRootIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stateRootIn"))
			it.StateRootIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "stateRootNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stateRootNotIn"))
			it.StateRootNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "stateRootGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stateRootGT"))
			it.StateRootGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "stateRootGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stateRootGTE"))
			it.StateRootGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "stateRootLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stateRootLT"))
			it.StateRootLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "stateRootLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stateRootLTE"))
			it.StateRootLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "stateRootContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stateRootContains"))
			it.StateRootContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "stateRootHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stateRootHasPrefix"))
			it.StateRootHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "stateRootHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stateRootHasSuffix"))
			it.StateRootHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "stateRootEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stateRootEqualFold"))
			it.StateRootEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "stateRootContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stateRootContainsFold"))
			it.StateRootContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "status":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			it.Status, err = ec.unmarshalOBlockStatus2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚋblockᚐStatus(ctx, v)
			if err != nil {
				return it, err
			}
		case "statusNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statusNEQ"))
			it.StatusNeq, err = ec.unmarshalOBlockStatus2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚋblockᚐStatus(ctx, v)
			if err != nil {
				return it, err
			}
		case "statusIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statusIn"))
			it.StatusIn, err = ec.unmarshalOBlockStatus2ᚕgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚋblockᚐStatusᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "statusNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statusNotIn"))
			it.StatusNotIn, err = ec.unmarshalOBlockStatus2ᚕgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚋblockᚐStatusᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "timestamp":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestamp"))
			it.Timestamp, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "timestampNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestampNEQ"))
			it.TimestampNeq, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "timestampIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestampIn"))
			it.TimestampIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "timestampNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestampNotIn"))
			it.TimestampNotIn, err = ec.unmarshalOTime2ᚕᚖtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "timestampGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestampGT"))
			it.TimestampGt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "timestampGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestampGTE"))
			it.TimestampGte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "timestampLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestampLT"))
			it.TimestampLt, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "timestampLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestampLTE"))
			it.TimestampLte, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNeq, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasTransactions":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactions"))
			it.HasTransactions, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasTransactionsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionsWith"))
			it.HasTransactionsWith, err = ec.unmarshalOTransactionWhereInput2ᚕᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋgqlᚐTransactionWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTransactionWhereInput(ctx context.Context, obj interface{}) (TransactionWhereInput, error) {
	var it TransactionWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOTransactionWhereInput2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋgqlᚐTransactionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOTransactionWhereInput2ᚕᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋgqlᚐTransactionWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOTransactionWhereInput2ᚕᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋgqlᚐTransactionWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "contractAddress":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contractAddress"))
			it.ContractAddress, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "contractAddressNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contractAddressNEQ"))
			it.ContractAddressNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "contractAddressIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contractAddressIn"))
			it.ContractAddressIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "contractAddressNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contractAddressNotIn"))
			it.ContractAddressNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "contractAddressGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contractAddressGT"))
			it.ContractAddressGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "contractAddressGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contractAddressGTE"))
			it.ContractAddressGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "contractAddressLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contractAddressLT"))
			it.ContractAddressLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "contractAddressLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contractAddressLTE"))
			it.ContractAddressLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "contractAddressContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contractAddressContains"))
			it.ContractAddressContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "contractAddressHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contractAddressHasPrefix"))
			it.ContractAddressHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "contractAddressHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contractAddressHasSuffix"))
			it.ContractAddressHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "contractAddressEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contractAddressEqualFold"))
			it.ContractAddressEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "contractAddressContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contractAddressContainsFold"))
			it.ContractAddressContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entryPointSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entryPointSelector"))
			it.EntryPointSelector, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entryPointSelectorNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entryPointSelectorNEQ"))
			it.EntryPointSelectorNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entryPointSelectorIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entryPointSelectorIn"))
			it.EntryPointSelectorIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "entryPointSelectorNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entryPointSelectorNotIn"))
			it.EntryPointSelectorNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "entryPointSelectorGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entryPointSelectorGT"))
			it.EntryPointSelectorGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entryPointSelectorGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entryPointSelectorGTE"))
			it.EntryPointSelectorGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entryPointSelectorLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entryPointSelectorLT"))
			it.EntryPointSelectorLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entryPointSelectorLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entryPointSelectorLTE"))
			it.EntryPointSelectorLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entryPointSelectorContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entryPointSelectorContains"))
			it.EntryPointSelectorContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entryPointSelectorHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entryPointSelectorHasPrefix"))
			it.EntryPointSelectorHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entryPointSelectorHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entryPointSelectorHasSuffix"))
			it.EntryPointSelectorHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entryPointSelectorEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entryPointSelectorEqualFold"))
			it.EntryPointSelectorEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entryPointSelectorContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entryPointSelectorContainsFold"))
			it.EntryPointSelectorContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entryPointType":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entryPointType"))
			it.EntryPointType, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entryPointTypeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entryPointTypeNEQ"))
			it.EntryPointTypeNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entryPointTypeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entryPointTypeIn"))
			it.EntryPointTypeIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "entryPointTypeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entryPointTypeNotIn"))
			it.EntryPointTypeNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "entryPointTypeGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entryPointTypeGT"))
			it.EntryPointTypeGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entryPointTypeGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entryPointTypeGTE"))
			it.EntryPointTypeGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entryPointTypeLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entryPointTypeLT"))
			it.EntryPointTypeLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entryPointTypeLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entryPointTypeLTE"))
			it.EntryPointTypeLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entryPointTypeContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entryPointTypeContains"))
			it.EntryPointTypeContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entryPointTypeHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entryPointTypeHasPrefix"))
			it.EntryPointTypeHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entryPointTypeHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entryPointTypeHasSuffix"))
			it.EntryPointTypeHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entryPointTypeEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entryPointTypeEqualFold"))
			it.EntryPointTypeEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "entryPointTypeContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entryPointTypeContainsFold"))
			it.EntryPointTypeContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionHash":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionHash"))
			it.TransactionHash, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionHashNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionHashNEQ"))
			it.TransactionHashNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionHashIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionHashIn"))
			it.TransactionHashIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionHashNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionHashNotIn"))
			it.TransactionHashNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionHashGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionHashGT"))
			it.TransactionHashGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionHashGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionHashGTE"))
			it.TransactionHashGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionHashLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionHashLT"))
			it.TransactionHashLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionHashLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionHashLTE"))
			it.TransactionHashLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionHashContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionHashContains"))
			it.TransactionHashContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionHashHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionHashHasPrefix"))
			it.TransactionHashHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionHashHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionHashHasSuffix"))
			it.TransactionHashHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionHashEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionHashEqualFold"))
			it.TransactionHashEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionHashContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionHashContainsFold"))
			it.TransactionHashContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalOType2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚋtransactionᚐType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			it.TypeNeq, err = ec.unmarshalOType2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚋtransactionᚐType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			it.TypeIn, err = ec.unmarshalOType2ᚕgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚋtransactionᚐTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			it.TypeNotIn, err = ec.unmarshalOType2ᚕgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚋtransactionᚐTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nonce":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonce"))
			it.Nonce, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nonceNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonceNEQ"))
			it.NonceNeq, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nonceIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonceIn"))
			it.NonceIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nonceNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonceNotIn"))
			it.NonceNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nonceGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonceGT"))
			it.NonceGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nonceGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonceGTE"))
			it.NonceGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nonceLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonceLT"))
			it.NonceLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nonceLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonceLTE"))
			it.NonceLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nonceContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonceContains"))
			it.NonceContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nonceHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonceHasPrefix"))
			it.NonceHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nonceHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonceHasSuffix"))
			it.NonceHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nonceEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonceEqualFold"))
			it.NonceEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nonceContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonceContainsFold"))
			it.NonceContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNeq, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasBlock":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBlock"))
			it.HasBlock, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasBlockWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBlockWith"))
			it.HasBlockWith, err = ec.unmarshalOBlockWhereInput2ᚕᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋgqlᚐBlockWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Node(ctx context.Context, sel ast.SelectionSet, obj ent.Noder) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case *ent.Block:
		if obj == nil {
			return graphql.Null
		}
		return ec._Block(ctx, sel, obj)
	case *ent.Transaction:
		if obj == nil {
			return graphql.Null
		}
		return ec._Transaction(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var blockImplementors = []string{"Block", "Node"}

func (ec *executionContext) _Block(ctx context.Context, sel ast.SelectionSet, obj *ent.Block) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, blockImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Block")
		case "id":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Block_id(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "blockHash":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Block_blockHash(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "parentBlockHash":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Block_parentBlockHash(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "blockNumber":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Block_blockNumber(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "stateRoot":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Block_stateRoot(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "status":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Block_status(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "timestamp":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Block_timestamp(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var blockConnectionImplementors = []string{"BlockConnection"}

func (ec *executionContext) _BlockConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.BlockConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, blockConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BlockConnection")
		case "edges":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._BlockConnection_edges(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "pageInfo":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._BlockConnection_pageInfo(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._BlockConnection_totalCount(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var blockEdgeImplementors = []string{"BlockEdge"}

func (ec *executionContext) _BlockEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.BlockEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, blockEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BlockEdge")
		case "node":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._BlockEdge_node(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "cursor":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._BlockEdge_cursor(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *ent.PageInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pageInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "hasNextPage":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._PageInfo_hasNextPage(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hasPreviousPage":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._PageInfo_hasPreviousPage(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "startCursor":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._PageInfo_startCursor(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "endCursor":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._PageInfo_endCursor(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var transactionImplementors = []string{"Transaction", "Node"}

func (ec *executionContext) _Transaction(ctx context.Context, sel ast.SelectionSet, obj *ent.Transaction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Transaction")
		case "id":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Transaction_id(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "contractAddress":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Transaction_contractAddress(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "entryPointSelector":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Transaction_entryPointSelector(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "entryPointType":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Transaction_entryPointType(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "transactionHash":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Transaction_transactionHash(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Transaction_type(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "nonce":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Transaction_nonce(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var transactionConnectionImplementors = []string{"TransactionConnection"}

func (ec *executionContext) _TransactionConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.TransactionConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionConnection")
		case "edges":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._TransactionConnection_edges(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "pageInfo":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._TransactionConnection_pageInfo(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._TransactionConnection_totalCount(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var transactionEdgeImplementors = []string{"TransactionEdge"}

func (ec *executionContext) _TransactionEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.TransactionEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionEdge")
		case "node":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._TransactionEdge_node(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

		case "cursor":
			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				return ec._TransactionEdge_cursor(ctx, field, obj)
			}

			out.Values[i] = innerFunc(ctx)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBlockOrderField2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐBlockOrderField(ctx context.Context, v interface{}) (*ent.BlockOrderField, error) {
	var res = new(ent.BlockOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBlockOrderField2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐBlockOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.BlockOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNBlockStatus2githubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚋblockᚐStatus(ctx context.Context, v interface{}) (block.Status, error) {
	var res block.Status
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBlockStatus2githubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚋblockᚐStatus(ctx context.Context, sel ast.SelectionSet, v block.Status) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNBlockWhereInput2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋgqlᚐBlockWhereInput(ctx context.Context, v interface{}) (*BlockWhereInput, error) {
	res, err := ec.unmarshalInputBlockWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCursor2githubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐCursor(ctx context.Context, v interface{}) (ent.Cursor, error) {
	var res ent.Cursor
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCursor2githubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐCursor(ctx context.Context, sel ast.SelectionSet, v ent.Cursor) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNNode2ᚕgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐNoder(ctx context.Context, sel ast.SelectionSet, v []ent.Noder) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalONode2githubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐNoder(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNOrderDirection2githubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐOrderDirection(ctx context.Context, v interface{}) (ent.OrderDirection, error) {
	var res ent.OrderDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOrderDirection2githubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐOrderDirection(ctx context.Context, sel ast.SelectionSet, v ent.OrderDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNPageInfo2githubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐPageInfo(ctx context.Context, sel ast.SelectionSet, v ent.PageInfo) graphql.Marshaler {
	return ec._PageInfo(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNTransactionWhereInput2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋgqlᚐTransactionWhereInput(ctx context.Context, v interface{}) (*TransactionWhereInput, error) {
	res, err := ec.unmarshalInputTransactionWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNType2githubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚋtransactionᚐType(ctx context.Context, v interface{}) (transaction.Type, error) {
	var res transaction.Type
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNType2githubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚋtransactionᚐType(ctx context.Context, sel ast.SelectionSet, v transaction.Type) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalOBlock2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐBlock(ctx context.Context, sel ast.SelectionSet, v *ent.Block) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Block(ctx, sel, v)
}

func (ec *executionContext) marshalOBlockConnection2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐBlockConnection(ctx context.Context, sel ast.SelectionSet, v *ent.BlockConnection) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BlockConnection(ctx, sel, v)
}

func (ec *executionContext) marshalOBlockEdge2ᚕᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐBlockEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.BlockEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOBlockEdge2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐBlockEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOBlockEdge2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐBlockEdge(ctx context.Context, sel ast.SelectionSet, v *ent.BlockEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BlockEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBlockOrder2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐBlockOrder(ctx context.Context, v interface{}) (*ent.BlockOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputBlockOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBlockStatus2ᚕgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚋblockᚐStatusᚄ(ctx context.Context, v interface{}) ([]block.Status, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]block.Status, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNBlockStatus2githubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚋblockᚐStatus(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOBlockStatus2ᚕgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚋblockᚐStatusᚄ(ctx context.Context, sel ast.SelectionSet, v []block.Status) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBlockStatus2githubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚋblockᚐStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOBlockStatus2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚋblockᚐStatus(ctx context.Context, v interface{}) (*block.Status, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(block.Status)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBlockStatus2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚋblockᚐStatus(ctx context.Context, sel ast.SelectionSet, v *block.Status) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOBlockWhereInput2ᚕᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋgqlᚐBlockWhereInputᚄ(ctx context.Context, v interface{}) ([]*BlockWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*BlockWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNBlockWhereInput2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋgqlᚐBlockWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOBlockWhereInput2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋgqlᚐBlockWhereInput(ctx context.Context, v interface{}) (*BlockWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputBlockWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCursor2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐCursor(ctx context.Context, v interface{}) (*ent.Cursor, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(ent.Cursor)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCursor2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐCursor(ctx context.Context, sel ast.SelectionSet, v *ent.Cursor) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalONode2githubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐNoder(ctx context.Context, sel ast.SelectionSet, v ent.Noder) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Node(ctx, sel, v)
}

func (ec *executionContext) marshalOTransaction2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐTransaction(ctx context.Context, sel ast.SelectionSet, v *ent.Transaction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Transaction(ctx, sel, v)
}

func (ec *executionContext) marshalOTransactionEdge2ᚕᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐTransactionEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.TransactionEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTransactionEdge2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐTransactionEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOTransactionEdge2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚐTransactionEdge(ctx context.Context, sel ast.SelectionSet, v *ent.TransactionEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TransactionEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTransactionWhereInput2ᚕᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋgqlᚐTransactionWhereInputᚄ(ctx context.Context, v interface{}) ([]*TransactionWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*TransactionWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTransactionWhereInput2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋgqlᚐTransactionWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTransactionWhereInput2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋgqlᚐTransactionWhereInput(ctx context.Context, v interface{}) (*TransactionWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTransactionWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOType2ᚕgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚋtransactionᚐTypeᚄ(ctx context.Context, v interface{}) ([]transaction.Type, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]transaction.Type, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNType2githubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚋtransactionᚐType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOType2ᚕgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚋtransactionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []transaction.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNType2githubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚋtransactionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOType2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚋtransactionᚐType(ctx context.Context, v interface{}) (*transaction.Type, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(transaction.Type)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOType2ᚖgithubᚗcomᚋtarrencevᚋstarknetᚑindexerᚋentᚋtransactionᚐType(ctx context.Context, sel ast.SelectionSet, v *transaction.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

// endregion ***************************** type.gotpl *****************************
